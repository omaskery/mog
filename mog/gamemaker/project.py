"""
this module provides functionality for parsing a game maker project file
"""


import xml.etree.ElementTree as etree
import os


class Project(object):
    """Represents a Game Maker project"""

    def __init__(self, base_path):
        self._base_path = base_path
        self._contents = etree.parse(Project.path_from_base(self._base_path))

    @property
    def objects(self):
        return list(map(lambda x: GameObject.from_xml_element(self._base_path, x), self._fetch_assets(".//object")))

    def fetch_object(self, name):
        for obj in self.objects:
            if obj.name == name:
                return obj
        return None

    def create_or_fetch_object(self, name):
        result = self.fetch_object(name)
        if result is None:
            result = GameObject.from_name(self._base_path, name)
        return result

    def _fetch_assets(self, asset_type):
        return self._contents.findall(asset_type)

    @staticmethod
    def name_from_path(base_path):
        return os.path.split(base_path)[-1].split(".")[0]

    @staticmethod
    def path_from_base(base_path):
        filename = "{}.project.gmx".format(Project.name_from_path(base_path))
        return os.path.join(base_path, filename)


class GameObject(object):
    """Represents an 'object' from a Game Maker project"""

    def __init__(self, name, path, contents):
        self._name = name
        self._path = path
        self._contents = contents

    @staticmethod
    def from_xml_element(base_path, elem):
        path = os.path.join(base_path, elem.text) + ".object.gmx"
        name = os.path.split(elem.text)[-1]
        return GameObject(name, path, etree.parse(path))

    @staticmethod
    def from_name(base_path, name):
        path = os.path.join(base_path, name) + ".object.gmx"
        object_element = etree.XML("""
            <!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
            <object>
                <spriteName>&lt;undefined&gt;</spriteName>
                <solid>0</solid>
                <visible>-1</visible>
                <depth>0</depth>
                <persistent>0</persistent>
                <parentName>&lt;undefined&gt;</parentName>
                <maskName>&lt;undefined&gt;</maskName>
                <events>
                </event>
                </events>
                <PhysicsObject>0</PhysicsObject>
                <PhysicsObjectSensor>0</PhysicsObjectSensor>
                <PhysicsObjectShape>0</PhysicsObjectShape>
                <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
                <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
                <PhysicsObjectGroup>0</PhysicsObjectGroup>
                <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
                <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
                <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
                <PhysicsObjectAwake>-1</PhysicsObjectAwake>
                <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
                <PhysicsShapePoints/>
            </object>
        """)
        return GameObject(name, path, object_element)

    @property
    def events(self):
        return list(map(lambda elem: GameObjectEvent.from_xml_element(elem, self), self._contents.findall(".//event")))

    def fetch_event_by_numbers(self, event_type, event_number):
        for event in self.events:
            if event.type == event_type and event.number == event_number:
                return event
        return None

    def create_or_fetch_event(self, event_type, event_number):
        event = self.fetch_event_by_numbers(event_type, event_number)
        if event is None:
            events_root = self._contents.find(".//events")
            event = GameObjectEvent.from_event_numbers(self, event_type, event_number)
            events_root.append(event.element)
        return event

    def save(self):
        root_obj = self._contents.getroot()
        if root_obj is not None:
            with open(self._path, 'w') as handle:
                handle.write(etree.tostring(root_obj).decode())

    @property
    def name(self):
        return self._name

    @property
    def path(self):
        return self._path

    @property
    def parent_name(self):
        element = self._contents.find(".//parentName")
        if element is not None and element.text != "<undefined>":
            result = element.text
        else:
            result = None
        return result

    def __str__(self):
        return "GameObject({})".format(self._name)

    def __repr__(self):
        return str(self)


class GameObjectEvent(object):
    """Represents an 'event' from an 'object' in Game Maker"""

    def __init__(self, parent, event_type, event_number, element):
        self._parent_object = parent
        self._event_type = event_type
        self._event_number = event_number
        self._element = element

    @staticmethod
    def from_xml_element(elem, parent):
        return GameObjectEvent(
            parent,
            int(elem.attrib['eventtype']),
            int(elem.attrib['enumb']),
            elem
        )

    @staticmethod
    def from_event_numbers(parent, event_type, event_number):
        elem = etree.XML("""
            <event eventtype="{}" enumb="{}">
            </event>
        """.format(event_type, event_number))
        return GameObjectEvent(
            parent,
            event_type,
            event_number,
            elem
        )

    def set_code_action(self, code):
        if len(self.code_actions) == 0:
            action_element = etree.XML("""
                <action>
                    <libid>1</libid>
                        <id>603</id>
                        <kind>7</kind>
                        <userelative>0</userelative>
                        <isquestion>0</isquestion>
                        <useapplyto>-1</useapplyto>
                        <exetype>2</exetype>
                        <functionname></functionname>
                        <codestring></codestring>
                        <whoName>self</whoName>
                        <relative>0</relative>
                        <isnot>0</isnot>
                        <arguments>
                            <argument>
                                <kind>1</kind>
                                <string>
                                </string>
                            </argument>
                        </arguments>
                </action>
            """)
            self.element.append(action_element)
        self.element.find(".//string").text = code

    @property
    def element(self):
        return self._element

    @property
    def code_actions(self):
        def code_only(elem):
            return elem.find('id').text == '603' and elem.find('kind').text == '7'

        def code_map(elem):
            return {
                'whoName': elem.find('whoName').text,
                'code': elem.find('arguments').find('argument').find('string').text,
            }

        return list(map(code_map, filter(code_only, self._element.findall('.//action'))))

    @property
    def parent(self):
        return self._parent_object

    @property
    def type(self):
        return self._event_type

    @property
    def type_name(self):
        return event_type_string(self.type)

    @property
    def number(self):
        return self._event_number

    def __str__(self):
        return "{}.Event({}, {})".format(self.parent, self.type_name, self.number)

    def __repr__(self):
        return str(self)


# based on manually editing *.object.gml file to have events with these numbers, fun!
EVENT_TYPE_CREATE = 0
EVENT_TYPE_DESTROY = 1
EVENT_TYPE_ALARM = 2
EVENT_TYPE_STEP = 3
EVENT_TYPE_COLLISION = 4
EVENT_TYPE_KEYBOARD = 5
EVENT_TYPE_MOUSE = 6
EVENT_TYPE_OTHER = 7
EVENT_TYPE_DRAW = 8
EVENT_TYPE_KEYPRESS = 9
EVENT_TYPE_KEYRELEASE = 10
EVENT_TYPE_TRIGGER = 11  # deprecated


EVENT_TYPE_MAPPING = {
    EVENT_TYPE_CREATE: 'create',
    EVENT_TYPE_DESTROY: 'destroy',
    EVENT_TYPE_STEP: 'step',
    EVENT_TYPE_ALARM: 'alarm',
    EVENT_TYPE_KEYBOARD: 'keyboard',
    EVENT_TYPE_MOUSE: 'mouse',
    EVENT_TYPE_COLLISION: 'collision',
    EVENT_TYPE_OTHER: 'other',
    EVENT_TYPE_DRAW: 'draw',
    EVENT_TYPE_KEYPRESS: 'keypress',
    EVENT_TYPE_KEYRELEASE: 'keyrelease',
    EVENT_TYPE_TRIGGER: 'trigger',
}


def event_type_string(event_type):
    """Returns a string describing the event type integer"""
    return EVENT_TYPE_MAPPING[event_type]


def event_type_number(event_name):
    """Returns the number from the given event type name"""
    for key, value in EVENT_TYPE_MAPPING.items():
        if value == event_name:
            return key
    return None
